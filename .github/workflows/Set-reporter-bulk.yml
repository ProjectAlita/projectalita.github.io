name: Set Reporter field for issues

on:
  workflow_dispatch:
    inputs:
      max_issues:
        description: "Maximum number of open issues to process (1-100)"
        required: false
        default: "100"
      concurrency_limit:
        description: "Concurrent updates (1-20). Higher = faster, but watch rate limits."
        required: false
        default: "8"

jobs:
  set-reporter-bulk:
    runs-on: ubuntu-latest

    permissions:
      contents: read
      issues: write

    env:
      ORG_LOGIN: ProjectAlita
      PROJECT_NUMBER: "3"
      PROJECT_TITLE: "ELITEA Board"
      REPORTER_FIELD_NAME: "Reporter"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Collect open issues (limit by input)
        id: list_issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          result-encoding: string
          script: |
            const maxIssues = Math.max(1, Math.min(100, parseInt(core.getInput('max_issues') || '100', 10)));
            const { owner, repo } = context.repo;

            const issues = await github.paginate(
              github.rest.issues.listForRepo,
              { owner, repo, state: 'open', per_page: Math.min(maxIssues, 100) }
            );

            const list = issues.slice(0, maxIssues).map(i => ({
              number: i.number,
              node_id: i.node_id,
              reporter: i.user.login
            }));
            core.info(`Collected ${list.length} open issues (max ${maxIssues}).`);
            return JSON.stringify(list)

      - name: Ensure items in project and set Reporter field (optimized, skip existing)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_TOKEN }}
          script: |
            const { ORG_LOGIN, PROJECT_NUMBER, PROJECT_TITLE, REPORTER_FIELD_NAME } = process.env;

            const raw = `${{ steps.list_issues.outputs.result }}`;
            const issues = raw ? JSON.parse(raw) : [];
            const concurrencyLimit = Math.max(1, Math.min(20, parseInt(core.getInput('concurrency_limit') || '8', 10)));

            if (!issues.length) {
              core.info('No open issues to process.');
              return;
            }

            // Resolve ProjectV2 (number → title fallback)
            const projectByNumberQuery = `
              query($org: String!, $number: Int!) {
                organization(login: $org) {
                  projectV2(number: $number) { id title }
                }
              }
            `;
            const projectsByTitleQuery = `
              query($org: String!, $query: String!, $first: Int!) {
                organization(login: $org) {
                  projectsV2(first: $first, query: $query) {
                    nodes { id title }
                  }
                }
              }
            `;

            let projectId = null;
            try {
              const resp = await github.graphql(projectByNumberQuery, {
                org: ORG_LOGIN,
                number: parseInt(PROJECT_NUMBER, 10),
              });
              projectId = resp?.organization?.projectV2?.id || null;
              if (projectId) {
                core.info(`Resolved project by number: ${resp.organization.projectV2.title} (ID: ${projectId})`);
              } else {
                core.info(`ProjectV2 #${PROJECT_NUMBER} not found by number; trying title lookup...`);
              }
            } catch (e) {
              core.info(`Lookup by number failed: ${e.message}. Trying title lookup...`);
            }

            if (!projectId) {
              const resp2 = await github.graphql(projectsByTitleQuery, {
                org: ORG_LOGIN,
                query: PROJECT_TITLE,
                first: 20,
              });
              const candidates = resp2?.organization?.projectsV2?.nodes || [];
              const match = candidates.find(p => p.title === PROJECT_TITLE);
              if (!match) {
                core.setFailed(`Could not resolve Projects v2 titled "${PROJECT_TITLE}" in org ${ORG_LOGIN}.`);
                return;
              }
              projectId = match.id;
              core.info(`Resolved project by title: ${PROJECT_TITLE} (ID: ${projectId})`);
            }

            // Fetch fields to find "Reporter" node id
            const fieldsQuery = `
              query($projectId: ID!, $first: Int!, $after: String) {
                node(id: $projectId) {
                  ... on ProjectV2 {
                    fields(first: $first, after: $after) {
                      nodes {
                        __typename
                        ... on ProjectV2Field { id name }
                        ... on ProjectV2IterationField { id name }
                        ... on ProjectV2SingleSelectField { id name }
                      }
                      pageInfo { endCursor hasNextPage }
                    }
                  }
                }
              }
            `;
            let reporterFieldId = null;
            let fAfter = null;
            while (true) {
              const res = await github.graphql(fieldsQuery, { projectId, first: 50, after: fAfter });
              const fields = res?.node?.fields?.nodes || [];
              for (const f of fields) {
                if (f?.name === REPORTER_FIELD_NAME) {
                  reporterFieldId = f.id;
                  break;
                }
              }
              if (reporterFieldId || !res.node.fields.pageInfo.hasNextPage) break;
              fAfter = res.node.fields.pageInfo.endCursor;
            }
            if (!reporterFieldId) {
              core.setFailed(`Field "${REPORTER_FIELD_NAME}" not found on project.`);
              return;
            }
            core.info(`Reporter field ID: ${reporterFieldId}`);

            // Fetch all project items once and map Issue node_id → { itemId, reporterValue }
            const listAllItemsQuery = `
              query($projectId: ID!, $first: Int!, $after: String) {
                node(id: $projectId) {
                  ... on ProjectV2 {
                    items(first: $first, after: $after) {
                      nodes {
                        id
                        fieldValues(first: 50) {
                          nodes {
                            ... on ProjectV2ItemFieldTextValue {
                              id
                              field { ... on ProjectV2Field { id name } }
                              text
                            }
                          }
                        }
                        content {
                          __typename
                          ... on Issue { id number }
                        }
                      }
                      pageInfo { endCursor hasNextPage }
                    }
                  }
                }
              }
            `;
            const issueItemMap = new Map(); // issueNodeId -> { itemId, reporterValue }
            let iAfter = null;
            let totalItems = 0;
            while (true) {
              const res = await github.graphql(listAllItemsQuery, { projectId, first: 100, after: iAfter });
              const items = res?.node?.items?.nodes || [];
              totalItems += items.length;
              for (const node of items) {
                if (node.content?.__typename === 'Issue') {
                  let existingReporter = null;
                  const fvNodes = node.fieldValues?.nodes || [];
                  for (const fv of fvNodes) {
                    const fieldName = fv?.field?.name;
                    if (fieldName === REPORTER_FIELD_NAME) {
                      existingReporter = fv?.text || null;
                      break;
                    }
                  }
                  issueItemMap.set(node.content.id, { itemId: node.id, reporterValue: existingReporter });
                }
              }
              if (!res.node.items.pageInfo.hasNextPage) break;
              iAfter = res.node.items.pageInfo.endCursor;
            }
            core.info(`Indexed ${totalItems} project items; mapped ${issueItemMap.size} issues to items with Reporter values.`);

            // Mutations
            const addItemMutation = `
              mutation($projectId: ID!, $contentId: ID!) {
                addProjectV2ItemById(input: { projectId: $projectId, contentId: $contentId }) {
                  item { id }
                }
              }
            `;
            const updateFieldMutationText = `
              mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $value: String!) {
                updateProjectV2ItemFieldValue(input: {
                  projectId: $projectId,
                  itemId: $itemId,
                  fieldId: $fieldId,
                  value: { text: $value }
                }) {
                  projectV2Item { id }
                }
              }
            `;

            // Concurrency control
            async function pLimit(limit, tasks) {
              const results = [];
              const executing = new Set();
              for (const task of tasks) {
                const p = Promise.resolve().then(task);
                results.push(p);
                executing.add(p);
                p.finally(() => executing.delete(p));
                if (executing.size >= limit) {
                  await Promise.race(executing);
                }
              }
              return Promise.all(results);
            }

            // Prepare tasks only for open issues
            const tasks = issues.map(({ number, node_id, reporter }) => async () => {
              try {
                const existing = issueItemMap.get(node_id);
                let itemId = existing?.itemId || null;
                let currentReporter = existing?.reporterValue || null;

                if (!itemId) {
                  // Add missing issue to project
                  const addResp = await github.graphql(addItemMutation, { projectId, contentId: node_id });
                  itemId = addResp.addProjectV2ItemById.item.id;
                  issueItemMap.set(node_id, { itemId, reporterValue: null });
                  core.info(`Issue #${number}: added to project as item ${itemId}`);
                } else {
                  core.info(`Issue #${number}: item exists ${itemId}`);
                }

                // Skip if Reporter already equals the issue author login
                if (currentReporter && currentReporter === reporter) {
                  core.info(`Issue #${number}: Reporter already "${reporter}", skipping.`);
                  return;
                }

                // Update Reporter field
                await github.graphql(updateFieldMutationText, {
                  projectId,
                  itemId,
                  fieldId: reporterFieldId,
                  value: reporter,
                });

                core.info(`Issue #${number}: Reporter="${reporter}" set on item ${itemId}`);
              } catch (err) {
                core.warning(`Issue #${number}: ${err.message}`);
              }
            });

            core.info(`Processing ${tasks.length} open issues with concurrency=${concurrencyLimit}...`);
            await pLimit(concurrencyLimit, tasks);
            core.info('Done.')
