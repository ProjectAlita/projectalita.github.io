name: Set Reporter field for issues in Project v2

on:
  workflow_dispatch:
    inputs:
      max_issues:
        description: "Maximum number of issues to process (1-100)"
        required: false
        default: "100"

jobs:
  set-reporter-bulk:
    runs-on: ubuntu-latest

    permissions:
      contents: read
      issues: write

    env:
      ORG_LOGIN: ProjectAlita
      PROJECT_NUMBER: "3"
      REPORTER_FIELD_ID: "243696364"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Collect open issues (limit by input)
        id: list_issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          result-encoding: string
          script: |
            const maxIssues = Math.max(1, Math.min(100, parseInt(core.getInput('max_issues') || '100', 10)));
            const { owner, repo } = context.repo;

            // Get open issues
            const issues = await github.paginate(
              github.rest.issues.listForRepo,
              { owner, repo, state: 'open', per_page: Math.min(maxIssues, 100) }
            );

            const list = issues.slice(0, maxIssues).map(i => ({ number: i.number, node_id: i.node_id, reporter: i.user.login }));
            core.info(`Collected ${list.length} open issues (max ${maxIssues}).`);
            return JSON.stringify(list)

      - name: Ensure items in project and set Reporter field
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { ORG_LOGIN, PROJECT_NUMBER, REPORTER_FIELD_ID } = process.env;

            // Parse previous step output safely
            const raw = `${{ steps.list_issues.outputs.result }}`;
            const issues = raw ? JSON.parse(raw) : [];
            if (!issues.length) {
              core.info('No issues to process.');
              return;
            }

            // Resolve ProjectV2 ID
            const projectQuery = `
              query($org: String!, $number: Int!) {
                organization(login: $org) {
                  projectV2(number: $number) { id }
                }
              }
            `;
            const projectResp = await github.graphql(projectQuery, {
              org: ORG_LOGIN,
              number: parseInt(PROJECT_NUMBER, 10),
            });
            const projectId = projectResp?.organization?.projectV2?.id;
            if (!projectId) {
              core.setFailed(`ProjectV2 #${PROJECT_NUMBER} not found in org ${ORG_LOGIN}`);
              return;
            }
            core.info(`ProjectV2 ID: ${projectId}`);

            // GraphQL defs
            const addItemMutation = `
              mutation($projectId: ID!, $contentId: ID!) {
                addProjectV2ItemById(input: { projectId: $projectId, contentId: $contentId }) {
                  item { id }
                }
              }
            `;
            const updateFieldMutation = `
              mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $value: String!) {
                updateProjectV2ItemFieldValue(input: {
                  projectId: $projectId,
                  itemId: $itemId,
                  fieldId: $fieldId,
                  value: { text: $value }
                }) {
                  projectV2Item { id }
                }
              }
            `;
            const listItemsQuery = `
              query($projectId: ID!, $after: String) {
                node(id: $projectId) {
                  ... on ProjectV2 {
                    items(first: 50, after: $after) {
                      nodes {
                        id
                        content {
                          __typename
                          ... on Issue { id number }
                        }
                      }
                      pageInfo { endCursor hasNextPage }
                    }
                  }
                }
              }
            `;

            // Helper: find or create project item for issue node
            async function ensureItemForIssue(issueNodeId, issueNumber) {
              let after = null;
              while (true) {
                const res = await github.graphql(listItemsQuery, { projectId, after });
                const items = res.node.items;

                const found = items.nodes.find(n => n.content?.__typename === 'Issue' && n.content?.id === issueNodeId);
                if (found) {
                  core.info(`Issue #${issueNumber}: existing item ${found.id}`);
                  return found.id;
                }

                if (!items.pageInfo.hasNextPage) break;
                after = items.pageInfo.endCursor;
              }

              // Not found, add it
              const addResp = await github.graphql(addItemMutation, { projectId, contentId: issueNodeId });
              const itemId = addResp.addProjectV2ItemById.item.id;
              core.info(`Issue #${issueNumber}: added item ${itemId}`);
              return itemId;
            }

            // Process each issue
            for (const { number, node_id, reporter } of issues) {
              try {
                const itemId = await ensureItemForIssue(node_id, number);
                await github.graphql(updateFieldMutation, {
                  projectId,
                  itemId,
                  fieldId: REPORTER_FIELD_ID,
                  value: reporter,
                });
                core.info(`Issue #${number}: Reporter="${reporter}" set on item ${itemId}`);
              } catch (err) {
                core.warning(`Issue #${number}: ${err.message}`);
              }
            }
